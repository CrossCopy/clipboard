# 2026-02-07

## 18:00 — Clipboard watcher: proper JS callback API replacing hardcoded demo

### Core Decision

Replace the old `watch()` function (a hardcoded 5-second demo that printed to stdout and blocked) with a production-quality `startWatch(callback)` API that accepts a JS callback and returns a stoppable handle.

### Options Considered

1. **Polling from JS** — Use `setInterval` on the JS side to periodically read clipboard contents and diff. Simple but inefficient, misses rapid changes, and duplicates work the OS can do natively.
2. **Native watcher with JS callback via ThreadsafeFunction** — Use `clipboard-rs`'s `ClipboardWatcherContext` (which uses OS-native change notifications) and bridge the callback to JS via napi's `ThreadsafeFunction`. Returns a handle object for stop control.
3. **EventEmitter / async iterator pattern** — More idiomatic Node.js but adds complexity and a dependency on `EventEmitter` interop from the native side for no clear gain.

### Final Decision & Rationale

Option 2. Matches the pattern already proven in `monio-napi` (`startListen` / `HookJs`), keeps the implementation in Rust with zero JS-side polling overhead, and gives the caller a simple synchronous `stop()` + `isRunning` interface. The `Arc<dyn Fn() + Send + Sync>` wrapper keeps the `CallbackHandler` struct decoupled from the concrete `ThreadsafeFunction` type.

### Key Changes Made

- **`src/lib.rs`** — Removed old `watch()`, `call_threadsafe_function()`, `Manager` struct, and dead commented-out code. Added:
  - `CallbackHandler` (internal) — implements `ClipboardHandler`, wraps a type-erased closure that calls the JS callback via `ThreadsafeFunction`.
  - `ClipboardWatcherJs` (exported `#[napi]` class) — holds `Arc<Mutex<Option<WatcherShutdown>>>`. `stop()` takes and drops the shutdown handle; `isRunning` getter checks presence.
  - `start_watch(callback)` (exported function) — converts JS `Function` to `ThreadsafeFunction`, creates watcher context, spawns a thread for the blocking `start_watch()` loop, returns handle.
- **`__test__/index.spec.ts`** — Replaced the placeholder test with 16 serial ava tests covering text round-trips, unicode, HTML, custom buffer formats, clear, `availableFormats`, `has*` flags, and four watcher-specific tests (lifecycle, idempotent stop, callback fires on change, callback silenced after stop).
- **`examples/demo.ts`** + **`examples/tsconfig.json`** — Interactive demo script exercising all clipboard features. Added `yarn demo` script to `package.json`.
- **`index.d.ts`** (auto-generated) — Now exports `ClipboardWatcherJs` class and `startWatch` function with correct TS signatures.

### Future Considerations

- The watcher tests rely on real OS clipboard access and 600ms sleeps between writes for the OS to register changes. CI environments without a display server (headless Linux) may need `xvfb` or similar, or these tests should be skipped in CI.
- `is_running` tracks whether `stop()` was called, not whether the background thread has actually exited. For this use case that's sufficient, but if precise thread-join semantics are ever needed, a `JoinHandle` could be stored alongside the shutdown channel.
- Error handling across the crate still uses `.unwrap()` for `ClipboardContext::new()` and clipboard operations. A follow-up could convert these to `Result` returns for better JS-side error messages.
